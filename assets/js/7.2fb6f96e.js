(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{406:function(t,e,v){t.exports=v.p+"assets/img/image-20230726163326945.1464f0ac.png"},407:function(t,e,v){t.exports=v.p+"assets/img/image-20230726163353282.3969c970.png"},408:function(t,e,v){t.exports=v.p+"assets/img/image-20230726163420036.ebfa740b.png"},409:function(t,e,v){t.exports=v.p+"assets/img/image-20230726163441337.ee344446.png"},410:function(t,e,v){t.exports=v.p+"assets/img/image-20230726163521352.6c28e480.png"},411:function(t,e,v){t.exports=v.p+"assets/img/image-20230726163629933.717fe940.png"},412:function(t,e,v){t.exports=v.p+"assets/img/image-20230726163709818.985c07c3.png"},413:function(t,e,v){t.exports=v.p+"assets/img/image-20230726163733470.7321e6e2.png"},423:function(t,e,v){"use strict";v.r(e);var n=v(0),_=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[e("a",{attrs:{name:"gnxxA"}})]),t._v(" "),e("h2",{attrs:{id:"变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[t._v("#")]),t._v(" 变量")]),t._v(" "),e("p",[t._v("在 JavaScript 中，每个运行的函数，代码块 "),e("code",[t._v("{...}")]),t._v(" 以及整个脚本，都有一个被称为 "),e("strong",[t._v("词法环境（Lexical Environment）")]),t._v(" 的内部（隐藏）的关联对象。"),e("br"),t._v("词法环境对象由两部分组成：")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("环境记录（Environment Record）")]),t._v(" —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 "),e("code",[t._v("this")]),t._v(" 的值）的对象。")]),t._v(" "),e("li",[t._v("对 "),e("strong",[t._v("外部词法环境")]),t._v(" 的引用，与外部代码相关联。")])]),t._v(" "),e("p",[t._v("一个“变量”只是 "),e("strong",[t._v("环境记录")]),t._v(" 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。"),e("br"),t._v("举个例子，这段没有函数的简单的代码中只有一个词法环境："),e("br")]),t._v(" "),e("p",[t._v("<img src=“..")]),t._v(" "),e("p",[t._v("这就是所谓的与整个脚本相关联的 "),e("strong",[t._v("全局")]),t._v(" 词法环境。"),e("br"),t._v("在上面的图片中，矩形表示环境记录（变量存储），箭头表示外部引用。全局词法环境没有外部引用，所以箭头指向了 "),e("code",[t._v("null")]),t._v("。"),e("br"),t._v("随着代码开始并继续运行，词法环境发生了变化。"),e("br"),t._v("这是更长的代码："),e("br")]),t._v(" "),e("img",{attrs:{src:v(406)}}),t._v(" "),e("p",[t._v("右侧的矩形演示了执行过程中全局词法环境的变化：")]),t._v(" "),e("ol",[e("li",[t._v("当脚本开始运行，词法环境预先填充了所有声明的变量。\n"),e("ul",[e("li",[t._v("最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 "),e("code",[t._v("let")]),t._v(" 声明前，不能引用它。几乎就像变量不存在一样。")])])]),t._v(" "),e("li",[t._v("然后 "),e("code",[t._v("let phrase")]),t._v(" 定义出现了。它尚未被赋值，因此它的值为 undefined。从这一刻起，我们就可以使用变量了。")]),t._v(" "),e("li",[e("code",[t._v("phrase")]),t._v(" 被赋予了一个值。")]),t._v(" "),e("li",[e("code",[t._v("phrase")]),t._v(" 的值被修改。")])]),t._v(" "),e("p",[t._v("现在看起来都挺简单的，是吧？")]),t._v(" "),e("ul",[e("li",[t._v("变量是特殊内部对象的属性，与当前正在执行的（代码）块/函数/脚本有关。")]),t._v(" "),e("li",[t._v("操作变量实际上是操作该对象的属性。")])]),t._v(" "),e("blockquote",[e("p",[t._v("ℹ️"),e("strong",[t._v("词法环境是一个规范对象")]),t._v("\n“词法环境”是一个规范对象（specification object）：它只存在于 "),e("a",{attrs:{href:"https://tc39.es/ecma262/#sec-lexical-environments",target:"_blank",rel:"noopener noreferrer"}},[t._v("语言规范"),e("OutboundLink")],1),t._v(" 的“理论”层面，用于描述事物是如何工作的。我们无法在代码中获取该对象并直接对其进行操作。\n但 JavaScript 引擎同样可以优化它，比如清除未被使用的变量以节省内存和执行其他内部技巧等，但显性行为应该是和上述的无差。")])]),t._v(" "),e("p",[e("a",{attrs:{name:"MPwgm"}})]),t._v(" "),e("h2",{attrs:{id:"函数声明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数声明"}},[t._v("#")]),t._v(" 函数声明")]),t._v(" "),e("p",[t._v("一个函数其实也是一个值，就像变量一样。"),e("br"),e("strong",[t._v("不同之处在于函数声明的初始化会被立即完成。")]),e("br"),t._v("当创建了一个词法环境（Lexical Environment）时，函数声明会立即变为即用型函数（不像 "),e("code",[t._v("let")]),t._v(" 那样直到声明处才可用）。"),e("br"),t._v("这就是为什么我们甚至可以在声明自身之前调用一个以函数声明（Function Declaration）的方式声明的函数。"),e("br"),t._v("例如，这是添加一个函数时全局词法环境的初始状态："),e("br"),t._v(" "),e("img",{attrs:{src:v(407)}})]),t._v(" "),e("p",[t._v("正常来说，这种行为仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 "),e("code",[t._v("let say = function(name)...")]),t._v("。\n"),e("a",{attrs:{name:"McYm0"}})]),t._v(" "),e("h2",{attrs:{id:"内部和外部的词法环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内部和外部的词法环境"}},[t._v("#")]),t._v(" 内部和外部的词法环境")]),t._v(" "),e("p",[t._v("在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。"),e("br"),t._v("例如，对于 "),e("code",[t._v('say("John")')]),t._v("，它看起来像这样（当前执行位置在箭头标记的那一行上）："),e("br")]),t._v(" "),e("img",{attrs:{src:v(408)}}),t._v(" "),e("p",[t._v("在这个函数调用期间，我们有两个词法环境：内部一个（用于函数调用）和外部一个（全局）：")]),t._v(" "),e("ul",[e("li",[t._v("内部词法环境与 "),e("code",[t._v("say")]),t._v(" 的当前执行相对应。它具有一个单独的属性："),e("code",[t._v("name")]),t._v("，函数的参数。我们调用的是 "),e("code",[t._v('say("John")')]),t._v("，所以 "),e("code",[t._v("name")]),t._v(" 的值为 "),e("code",[t._v('"John"')]),t._v("。")]),t._v(" "),e("li",[t._v("外部词法环境是全局词法环境。它具有 "),e("code",[t._v("phrase")]),t._v(" 变量和函数本身。")])]),t._v(" "),e("p",[t._v("内部词法环境引用了 "),e("code",[t._v("outer")]),t._v("。"),e("br"),e("strong",[t._v("当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。")]),e("br"),t._v("如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。"),e("br"),t._v("在这个示例中，搜索过程如下：")]),t._v(" "),e("ul",[e("li",[t._v("对于 "),e("code",[t._v("name")]),t._v(" 变量，当 "),e("code",[t._v("say")]),t._v(" 中的 "),e("code",[t._v("alert")]),t._v(" 试图访问 "),e("code",[t._v("name")]),t._v(" 时，会立即在内部词法环境中找到它。")]),t._v(" "),e("li",[t._v("当它试图访问 "),e("code",[t._v("phrase")]),t._v(" 时，然而内部没有 "),e("code",[t._v("phrase")]),t._v("，所以它顺着对外部词法环境的引用找到了它。")])]),t._v(" "),e("img",{attrs:{src:v(409)}}),t._v(" "),e("p",[e("a",{attrs:{name:"d6jKP"}})]),t._v(" "),e("h2",{attrs:{id:"返回函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#返回函数"}},[t._v("#")]),t._v(" 返回函数")]),t._v(" "),e("p",[t._v("让我们来看 "),e("code",[t._v("makeCounter")]),t._v(" 这个例子。")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("makeCounter")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" count "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" count"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" counter "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("makeCounter")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v("在每次 "),e("code",[t._v("makeCounter()")]),t._v(" 调用的开始，都会创建一个新的词法环境对象，以存储该 "),e("code",[t._v("makeCounter")]),t._v(" 运行时的变量。"),e("br"),t._v("因此，我们有两层嵌套的词法环境，就像上面的示例一样："),e("br")]),t._v(" "),e("img",{attrs:{src:v(410)}}),t._v(" "),e("p",[t._v("不同的是，在执行 "),e("code",[t._v("makeCounter()")]),t._v(" 的过程中创建了一个仅占一行的嵌套函数："),e("code",[t._v("return count++")]),t._v("。我们尚未运行它，仅创建了它。"),e("br"),t._v("所有的函数在“诞生”时都会记住创建它们的词法环境。从技术上讲，这里没有什么魔法：所有函数都有名为 "),e("code",[t._v("[[Environment]]")]),t._v(" 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。"),e("br")]),t._v(" "),e("img",{attrs:{src:v(411)}}),t._v(" "),e("p",[t._v("因此，"),e("code",[t._v("counter.[[Environment]]")]),t._v(" 有对 "),e("code",[t._v("{count: 0}")]),t._v(" 词法环境的引用。这就是函数记住它创建于何处的方式，与函数被在哪儿调用无关。"),e("code",[t._v("[[Environment]]")]),t._v(" 引用在函数创建时被设置并永久保存。"),e("br"),t._v("稍后，当调用 "),e("code",[t._v("counter()")]),t._v(" 时，会为该调用创建一个新的词法环境，并且其外部词法环境引用获取于 "),e("code",[t._v("counter.[[Environment]]")]),t._v("："),e("br")]),t._v(" "),e("img",{attrs:{src:v(412)}}),t._v("\n![image-20230726163709818](C:\\Users\\落叶Rakuyou\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230726163709818.png)\n"),e("p",[t._v("现在，当 "),e("code",[t._v("counter()")]),t._v(" 中的代码查找 "),e("code",[t._v("count")]),t._v(" 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 "),e("code",[t._v("makeCounter()")]),t._v(" 的词法环境，并且在哪里找到就在哪里修改。"),e("br"),e("strong",[t._v("在变量所在的词法环境中更新变量。")]),e("br"),t._v("这是执行后的状态："),e("br")]),t._v(" "),e("img",{attrs:{src:v(413)}}),t._v(" "),e("p",[t._v("如果我们调用 "),e("code",[t._v("counter()")]),t._v(" 多次，"),e("code",[t._v("count")]),t._v(" 变量将在同一位置增加到 "),e("code",[t._v("2")]),t._v("，"),e("code",[t._v("3")]),t._v(" 等。")]),t._v(" "),e("blockquote",[e("p",[t._v("ℹ️开发者通常应该都知道“闭包”这个通用的编程术语。\n"),e("a",{attrs:{href:"https://en.wikipedia.org/wiki/Closure_(computer_programming)",target:"_blank",rel:"noopener noreferrer"}},[t._v("闭包"),e("OutboundLink")],1),t._v(" 是指一个函数可以记住其外部变量并可以访问这些变量。在某些编程语言中，这是不可能的，或者应该以一种特殊的方式编写函数来实现。但如上所述，在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 "),e("a",{attrs:{href:"https://zh.javascript.info/new-function",target:"_blank",rel:"noopener noreferrer"}},[t._v('"new Function" 语法'),e("OutboundLink")],1),t._v(" 中讲到）。\n也就是说：JavaScript 中的函数会自动通过隐藏的 "),e("code",[t._v("[[Environment]]")]),t._v(" 属性记住创建它们的位置，所以它们都可以访问外部变量。\n在面试时，前端开发者通常会被问到“什么是闭包？”，正确的回答应该是闭包的定义，并解释清楚为什么 JavaScript 中的所有函数都是闭包的，以及可能的关于 "),e("code",[t._v("[[Environment]]")]),t._v(" 属性和词法环境原理的技术细节。")])])])}),[],!1,null,null,null);e.default=_.exports}}]);